<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Weather Client</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for better aesthetics */
        body::-webkit-scrollbar { width: 8px; }
        body::-webkit-scrollbar-track { background: #f0f4f8; }
        body::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        body::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4" style="font-family: 'Inter', sans-serif;">
    <div id="app" class="bg-white p-6 md:p-10 rounded-xl shadow-2xl w-full max-w-lg space-y-6">
        
        <header class="text-center">
            <h1 class="text-3xl font-extrabold text-blue-800">BLE Weather Sender</h1>
            <p class="text-gray-600 mt-1">Status for Hyderabad, India</p>
        </header>

        <!-- Fixed Location & Interval Display -->
        <div class="bg-blue-50 border-l-4 border-blue-400 text-blue-800 p-4 rounded-lg" role="alert">
            <p class="font-medium">Configuration Details:</p>
            <ul class="list-disc list-inside text-sm mt-1">
                <li>**Location:** Hyderabad, IN (Fixed)</li>
                <li>**Update Interval:** 2 minutes</li>
            </ul>
        </div>

        <!-- Connection and Status Sections -->
        <div class="space-y-4">
            <div class="p-5 bg-gray-50 rounded-lg shadow-inner">
                <h2 class="text-xl font-semibold text-gray-700 mb-3 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 11V7a4 4 0 118 0v4m-5 9h10a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2z" />
                    </svg>
                    BLE Connection Status
                </h2>
                <p id="connectionStatus" class="text-sm font-medium text-red-600">Disconnected</p>
            </div>
            
            <div class="p-5 bg-gray-50 rounded-lg shadow-inner">
                <h2 class="text-xl font-semibold text-gray-700 mb-3 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.976 4.002 4.002 0 10-7.756-1.125h-1.144" />
                    </svg>
                    Weather Update Status
                </h2>
                <p id="weatherDisplay" class="text-lg font-bold text-gray-800">Awaiting first fetch...</p>
                <p id="nextUpdate" class="text-sm text-gray-500 mt-2">Next update in...</p>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-col space-y-3 pt-4">
            <button id="connectButton" class="w-full py-3 px-6 rounded-lg font-bold text-white transition duration-200 shadow-md hover:shadow-lg bg-indigo-600 hover:bg-indigo-700">
                Connect to ESP32 Clock
            </button>
            <button id="sendDataButton" disabled class="w-full py-3 px-6 rounded-lg font-bold text-white bg-green-500 hover:bg-green-600 transition duration-200 shadow-md disabled:opacity-50 disabled:cursor-not-allowed">
                Send Weather Data Manually
            </button>
        </div>

    </div>

    <!-- Firebase and BLE JavaScript Logic -->
    <script type="module">
        // Import Firebase for basic initialization, though database is not used here, 
        // it's kept for compliance in the canvas environment.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- CONFIGURATION CONSTANTS (UPDATED) ---
        // Your new API Key
        const WEATHERAPI_API_KEY = "49571caca256410ab3c113826252510"; 
        // Fixed city location
        const FIXED_CITY = 'Hyderabad'; 
        // 2 minutes update interval
        const UPDATE_INTERVAL_MS = 120000; 
        // --- END CONFIGURATION ---

        const SERVICE_UUID = '4fa6b2d1-2184-4869-906f-42a98f79de3d';
        const CHARACTERISTIC_UUID = 'f8df127c-36b3-4f9e-a89a-0e7845f2a1b2';

        let device, server, service, characteristic;
        let lastWeatherFetchTime = 0;
        let updateIntervalId = null;
        let timerIntervalId = null;

        let currentTemp = '';
        let currentWeather = '';

        // UI Elements
        const connectionStatus = document.getElementById('connectionStatus');
        const weatherDisplay = document.getElementById('weatherDisplay');
        const nextUpdate = document.getElementById('nextUpdate');
        const connectButton = document.getElementById('connectButton');
        const sendDataButton = document.getElementById('sendDataButton');
        
        // --- FIREBASE INITIALIZATION ---
        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let firebaseConfig = {};
        try {
            firebaseConfig = JSON.parse(__firebase_config);
        } catch (e) {
            console.error("Firebase config is invalid or missing.", e);
        }

        let db, auth;
        
        // Initialize Firebase services
        if (Object.keys(firebaseConfig).length > 0) {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            // Authenticate using the provided token or anonymously
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            
            if (initialAuthToken) {
                signInWithCustomToken(auth, initialAuthToken)
                    .then(() => console.log("Firebase signed in with custom token."))
                    .catch(error => {
                        console.error("Error signing in with custom token:", error);
                        signInAnonymously(auth).then(() => console.log("Signed in anonymously instead.")).catch(e => console.error("Anon sign-in failed:", e));
                    });
            } else {
                signInAnonymously(auth)
                    .then(() => console.log("Firebase signed in anonymously."))
                    .catch(e => console.error("Anonymous sign-in failed:", e));
            }
        }
        // --- END FIREBASE INITIALIZATION ---


        /**
         * Fetches weather data from WeatherAPI.com.
         */
        async function fetchWeatherData() {
            
            const url = `https://api.weatherapi.com/v1/current.json?key=${WEATHERAPI_API_KEY}&q=${FIXED_CITY}&aqi=no`;
            
            console.log('Fetching weather data for:', FIXED_CITY); 

            try {
                // Implementing exponential backoff for the fetch call
                const maxRetries = 3;
                let response;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        response = await fetch(url);
                        if (response.ok) break;
                        
                        console.error(`Fetch attempt ${i + 1} failed with status: ${response.status}`); 
                    } catch (e) {
                        if (i === maxRetries - 1) throw e;
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                    }
                }

                // Check for final non-OK status after retries and throw a specific error
                if (!response.ok) {
                    throw new Error(`API request failed with status: ${response.status} after ${maxRetries} attempts.`);
                }

                const data = await response.json();

                if (data.current && data.location) {
                    // Extract temperature in Celsius and round to 1 decimal place
                    currentTemp = parseFloat(data.current.temp_c).toFixed(1);
                    
                    // Extract the text description of the weather condition
                    let conditionText = data.current.condition.text; 
                    
                    // --- UPDATED MAPPING LOGIC START (Prioritized) ---
                    // 1. Sunny/Clear
                    if (conditionText.includes('Sunny') || conditionText.includes('Clear')) {
                        currentWeather = 'Sunny';
                    } 
                    // 2. Rain/Thunder
                    else if (conditionText.includes('Rain') || conditionText.includes('Drizzle') || conditionText.includes('Thunder')) {
                        currentWeather = 'Rain';
                    } 
                    // 3. Cloudy/Overcast/Partly Cloudy
                    else if (conditionText.includes('Cloudy') || conditionText.includes('Overcast')) {
                        currentWeather = 'Cloudy';
                    } 
                    // 4. Fog/Mist
                    else if (conditionText.includes('Mist') || conditionText.includes('Fog')) {
                        currentWeather = 'Foggy';
                    } 
                    // Fallback: Truncate the original text
                    else {
                        // Truncate to a reasonable length if the description is long
                        currentWeather = conditionText.substring(0, 15);
                    }
                    // --- UPDATED MAPPING LOGIC END ---

                    weatherDisplay.textContent = `Weather: ${currentWeather}, ${currentTemp}Â°C in ${data.location.name}`;
                    lastWeatherFetchTime = Date.now(); // Record success time

                } else {
                    weatherDisplay.textContent = 'Error: No current weather data in API response.';
                }
            } catch (error) {
                console.error('Weather fetching error:', error);
                weatherDisplay.textContent = `Error fetching weather. Check console.`;
            }
        }

        /**
         * Connects to the BLE device.
         */
        function connect() {
            navigator.bluetooth.requestDevice({
                filters: [{ services: [SERVICE_UUID] }]
            })
            .then(d => {
                device = d;
                connectionStatus.textContent = 'Connecting...';
                device.addEventListener('gattserverdisconnected', onDisconnected);
                return device.gatt.connect();
            })
            .then(s => {
                server = s;
                return server.getPrimaryService(SERVICE_UUID);
            })
            .then(serv => {
                service = serv;
                return service.getCharacteristic(CHARACTERISTIC_UUID);
            })
            .then(char => {
                characteristic = char;
                connectionStatus.textContent = 'Connected!';
                connectionStatus.classList.remove('text-red-600');
                connectionStatus.classList.add('text-green-600');
                sendDataButton.disabled = false;
                
                // On successful connection, start the periodic update loop
                startPeriodicUpdates(); 
                
                // Immediately send the initial data upon connection
                sendWeatherData(); 
            })
            .catch(error => {
                console.error('Connection failed:', error);
                connectionStatus.textContent = 'Disconnected or Connection Error.';
                connectionStatus.classList.remove('text-green-600');
                connectionStatus.classList.add('text-red-600');
                sendDataButton.disabled = true;
                stopPeriodicUpdates();
                // Custom error message box instead of alert()
                showErrorMessage(`BLE Connection Error: ${error.message}`);
            });
        }

        /**
         * Sends the current weather and temp data to the BLE characteristic.
         */
        async function sendWeatherData() {
            if (!characteristic || !server.connected) {
                connectionStatus.textContent = 'Disconnected. Cannot send data.';
                sendDataButton.disabled = true;
                stopPeriodicUpdates();
                return;
            }

            // Ensure weather data is current before sending
            if (Date.now() - lastWeatherFetchTime > UPDATE_INTERVAL_MS * 1.5) {
                 await fetchWeatherData(); // Fetch new data if it's too old
            }

            if (!currentWeather || !currentTemp) {
                console.warn("Weather data not available yet. Skipping send.");
                return;
            }

            // Format: "WEATHER CONDITION|TEMP_C" (e.g., "Cloudy|23.2")
            const dataString = `${currentWeather}|${currentTemp}`;
            const encoder = new TextEncoder();
            const dataArray = encoder.encode(dataString);

            try {
                await characteristic.writeValue(dataArray);
                console.log(`Data sent successfully: ${dataString}`);
                sendDataButton.textContent = 'Data Sent!';
                setTimeout(() => sendDataButton.textContent = 'Send Weather Data Manually', 1000);
            } catch (error) {
                console.error('Error sending data:', error);
                // Custom error message box instead of alert()
                showErrorMessage(`BLE Send Error: ${error.message}`);
                sendDataButton.disabled = true;
                stopPeriodicUpdates();
            }
        }
        
        /**
         * Disconnect handler.
         */
        function onDisconnected(event) {
            console.log('Device disconnected:', event.target.name);
            connectionStatus.textContent = 'Disconnected.';
            connectionStatus.classList.remove('text-green-600');
            connectionStatus.classList.add('text-red-600');
            sendDataButton.disabled = true;
            stopPeriodicUpdates();
        }

        /**
         * Starts the periodic update and send loop.
         */
        function startPeriodicUpdates() {
            stopPeriodicUpdates(); // Clear any existing intervals first
            
            // 1. Fetch data immediately
            fetchWeatherData().then(() => {
                sendWeatherData();
            });

            // 2. Set interval for fetching and sending data
            updateIntervalId = setInterval(async () => {
                await fetchWeatherData();
                await sendWeatherData();
            }, UPDATE_INTERVAL_MS);

            // 3. Set interval for updating the countdown timer
            timerIntervalId = setInterval(updateCountdown, 1000);
            updateCountdown(); // Call immediately to initialize
        }
        
        /**
         * Stops the periodic update and send loop.
         */
        function stopPeriodicUpdates() {
            if (updateIntervalId) {
                clearInterval(updateIntervalId);
                updateIntervalId = null;
            }
            if (timerIntervalId) {
                clearInterval(timerIntervalId);
                timerIntervalId = null;
            }
            nextUpdate.textContent = 'Update loop stopped.';
        }

        /**
         * Updates the countdown display.
         */
        function updateCountdown() {
            if (lastWeatherFetchTime === 0 || !updateIntervalId) {
                nextUpdate.textContent = 'Awaiting connection to start updates.';
                return;
            }

            const elapsed = Date.now() - lastWeatherFetchTime;
            const remaining = UPDATE_INTERVAL_MS - elapsed;

            if (remaining > 0) {
                const seconds = Math.floor(remaining / 1000);
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                nextUpdate.textContent = `Next update in: ${mins}m ${secs}s`;
            } else {
                nextUpdate.textContent = 'Updating now...';
            }
        }
        
        /**
         * Custom error message display (replacing alert).
         */
        function showErrorMessage(message) {
            const errorContainer = document.createElement('div');
            errorContainer.className = "fixed bottom-4 right-4 bg-red-600 text-white p-4 rounded-lg shadow-xl max-w-sm z-50";
            errorContainer.innerHTML = `
                <p class="font-bold">System Message</p>
                <p class="text-sm mt-1">${message}</p>
            `;
            document.body.appendChild(errorContainer);
            setTimeout(() => {
                errorContainer.remove();
            }, 5000);
        }

        // Event Listeners
        connectButton.addEventListener('click', connect);
        sendDataButton.addEventListener('click', sendWeatherData);
        
        // Initial fetch on load to show current status immediately (no send)
        window.onload = () => {
             fetchWeatherData();
        }

    </script>
</body>
</html>
