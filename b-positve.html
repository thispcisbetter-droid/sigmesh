<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 BLE Data Sender</title>
    <!-- Load Tailwind CSS for simple, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font and basic styling */
        body { font-family: 'Inter', sans-serif; background-color: #f1f5f9; }
        .card { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); }
        .connect-btn { transition: background-color 0.3s, transform 0.1s; }
        .connect-btn:hover { background-color: #2563eb; }
        .connect-btn:active { transform: scale(0.98); }
        .auto-btn { background-color: #f97316; }
        .auto-btn:hover { background-color: #ea580c; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div id="app" class="w-full max-w-md bg-white p-6 rounded-xl card space-y-6">
        <h1 class="text-2xl font-bold text-gray-800 text-center">BLE Clock Controller</h1>
        <p class="text-sm text-gray-500 text-center">Connects to 'ESP32-OLED-Clock' and sends Time/Weather data.</p>
        
        <!-- Security Warning for Web Bluetooth -->
        <div id="bluetoothWarning" class="p-3 text-sm rounded-lg bg-yellow-100 text-yellow-800 border border-yellow-300 hidden">
            <strong class="font-bold">Important Note:</strong> 
            Web Bluetooth requires a **secure context (HTTPS)** and direct user interaction. 
            If the "SecurityError" persists, please save this HTML file locally and open it directly in a modern browser (like Chrome).
        </div>
        
        <!-- Connection Status & Button -->
        <div class="space-y-4">
            <button id="connectButton" onclick="connect()" 
                    class="connect-btn w-full px-4 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50">
                Connect to ESP32
            </button>
            <div id="status" class="p-3 text-center rounded-lg text-sm bg-blue-100 text-blue-800">
                Status: Disconnected. Click 'Connect' above.
            </div>
        </div>

        <!-- Automated Fetching -->
        <div id="autoData" class="space-y-4 pt-4 border-t border-gray-200">
            <h2 class="text-xl font-semibold text-gray-700">Automated Data</h2>
            <div id="currentLocation" class="text-sm text-center p-2 bg-gray-50 rounded-md">
                Location: Hyderabad (Fixed)
            </div>
            <button id="fetchButton" onclick="fetchAndSendWeatherData()" 
                    class="auto-btn w-full px-4 py-3 text-white font-semibold rounded-lg shadow-md focus:outline-none focus:ring-4 focus:ring-orange-500 focus:ring-opacity-50">
                Fetch Real-Time Weather & Send
            </button>
            <p class="text-xs text-gray-500 text-center">Recommended: Click the button, or enable the auto-update below.</p>
            <div class="flex items-center justify-between p-2 bg-gray-100 rounded-lg">
                <label for="autoUpdateCheckbox" class="text-sm font-medium text-gray-700">Auto-Update Weather (Every 5 min)</label>
                <input type="checkbox" id="autoUpdateCheckbox" onchange="toggleAutoUpdate()" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
            </div>
        </div>
        
        <!-- Manual Inputs (Hidden by default) -->
        <div id="dataInputs" class="space-y-4 pt-4 border-t border-gray-200" style="display: none;">
            <h2 class="text-xl font-semibold text-gray-700">Manual Override</h2>

            <!-- Time Input -->
            <div>
                <label for="inputTime" class="block text-sm font-medium text-gray-700 mb-1">Time (HH:MM)</label>
                <input type="time" id="inputTime" value="08:30" 
                       class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-3 border focus:border-indigo-500 focus:ring-indigo-500">
            </div>

            <!-- Temperature Input -->
            <div>
                <label for="inputTemp" class="block text-sm font-medium text-gray-700 mb-1">Temperature (°C)</label>
                <div class="relative mt-1 rounded-md shadow-sm">
                    <input type="number" id="inputTemp" value="25.5" step="0.1" 
                           class="block w-full pr-12 rounded-md border-gray-300 p-3 border focus:border-indigo-500 focus:ring-indigo-500">
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
                        <span class="text-gray-500 sm:text-sm">°C</span>
                    </div>
                </div>
            </div>

            <!-- Weather Input -->
            <div>
                <label for="inputWeather" class="block text-sm font-medium text-gray-700 mb-1">Weather Condition</label>
                <input type="text" id="inputWeather" value="Sunny"
                       class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-3 border bg-white focus:border-indigo-500 focus:ring-indigo-500">
            </div>

            <!-- Send Button -->
            <button onclick="sendManualData()" 
                    class="w-full px-4 py-3 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 focus:outline-none focus:ring-4 focus:ring-gray-400 focus:ring-opacity-50 mt-4">
                Send Manual Data
            </button>
            <p class="text-xs text-center text-gray-400">This mode sends the above values directly.</p>
        </div>

    </div>

    <script>
        // --- API & BLE Configuration ---
        // Updated to use WeatherAPI.com Key
        const WEATHER_API_KEY = "f433f239860742c1b8e134145252510"; 
        const TARGET_CITY = "Hyderabad";

        const SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-c5c9c331914b';
        const CHARACTERISTIC_UUID = 'beb5483e-36e1-4688-b7f5-ea07361b26a8';
        const DEVICE_NAME = 'ESP32-OLED-Clock'; 
        // -------------------------------------------------------------------

        let bleDevice;
        let dataCharacteristic;
        let isConnected = false;
        let autoUpdateInterval;
        // latitude and longitude are no longer strictly needed for the API call 
        // but kept for compatibility if needed later.
        let latitude = null; 
        let longitude = null; 
        
        // DOM Elements
        const statusElement = document.getElementById('status');
        const connectButton = document.getElementById('connectButton');
        const dataInputs = document.getElementById('dataInputs');
        const inputTime = document.getElementById('inputTime');
        const inputTemp = document.getElementById('inputTemp');
        const inputWeather = document.getElementById('inputWeather');
        const bluetoothWarning = document.getElementById('bluetoothWarning');
        const currentLocationElement = document.getElementById('currentLocation');

        // Initial checks
        if (!navigator.bluetooth) {
            bluetoothWarning.classList.remove('hidden');
            updateStatus('Browser does not support Web Bluetooth.', true);
            connectButton.disabled = true;
        } else {
            bluetoothWarning.classList.remove('hidden');
            // We set location display based on the TARGET_CITY
            currentLocationElement.textContent = `Location: ${TARGET_CITY} (Manual Target)`;
        }

        // --- Helper Functions ---

        /**
         * Utility function to update the status message on the UI.
         */
        function updateStatus(message, isError = false) {
            statusElement.textContent = `Status: ${message}`;
            statusElement.className = `p-3 text-center rounded-lg text-sm ${isError ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`;
        }
        
        /**
         * Original getLocation function is now simplified as we use a fixed city name.
         */
        function getLocation() {
            // Geolocation is bypassed since the target city is fixed.
            currentLocationElement.textContent = `Location: ${TARGET_CITY} (Fixed)`;
        }

        // --- BLE Functions ---

        /**
         * Connects to the ESP32 via Web Bluetooth.
         */
        async function connect() {
            if (!navigator.bluetooth) {
                 updateStatus('Browser does not support Web Bluetooth.', true);
                 return;
            }

            if (isConnected) {
                // If connected, clicking the button should disconnect
                if (bleDevice && bleDevice.gatt.connected) {
                    bleDevice.gatt.disconnect();
                } else {
                     updateStatus('Already connected, but disconnected unexpectedly. Trying to reconnect...');
                }
                return;
            }

            updateStatus('Scanning for device...');
            connectButton.disabled = true;

            try {
                // 1. Request the device, filtered by name
                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: DEVICE_NAME }],
                    optionalServices: [SERVICE_UUID]
                });

                updateStatus(`Connecting to ${bleDevice.name}...`);

                // Set up disconnection event listener
                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);

                // 2. Connect to the GATT server
                const server = await bleDevice.gatt.connect();

                // 3. Get the Service
                const service = await server.getPrimaryService(SERVICE_UUID);

                // 4. Get the Characteristic
                dataCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);

                isConnected = true;
                connectButton.textContent = 'Connected (Click to Disconnect)';
                connectButton.className = connectButton.className.replace('bg-indigo-600 hover:bg-indigo-700', 'bg-red-600 hover:bg-red-700');
                
                // Initialize time input to current time
                inputTime.value = new Date().toTimeString().substring(0, 5);

                updateStatus(`Successfully connected to ${bleDevice.name}. Ready to send data.`);
                
                // Automatically fetch and send data on successful connection
                fetchAndSendWeatherData();

            } catch (error) {
                let errorMessage = error.message;
                if (error.name === 'SecurityError') {
                    errorMessage = "Access to Bluetooth was denied by browser policy. See warning above.";
                } else if (error.name === 'NotFoundError') {
                    errorMessage = "Device not found or connection cancelled by user.";
                }
                updateStatus(`Connection Error: ${errorMessage}`, true);
                console.error(error);
                isConnected = false;
                connectButton.textContent = 'Connect to ESP32';
                connectButton.disabled = false;
                connectButton.className = connectButton.className.replace('bg-red-600 hover:bg-red-700', 'bg-indigo-600 hover:bg-indigo-700');
            }
        }

        /**
         * Handler for when the device disconnects unexpectedly.
         */
        function onDisconnected(event) {
            const device = event.target;
            console.log(`Device ${device.name} disconnected.`);
            updateStatus('Disconnected. Please click Connect to re-establish the connection.', true);
            isConnected = false;
            connectButton.textContent = 'Connect to ESP32';
            connectButton.disabled = false;
            connectButton.className = connectButton.className.replace('bg-red-600 hover:bg-red-700', 'bg-indigo-600 hover:bg-indigo-700');
            clearInterval(autoUpdateInterval);
            document.getElementById('autoUpdateCheckbox').checked = false;
        }

        /**
         * Formats and sends the data to the ESP32 characteristic.
         */
        async function sendData(dataString) {
            if (!isConnected || !dataCharacteristic) {
                updateStatus('Not connected. Please click Connect first.', true);
                return false;
            }

            const encoder = new TextEncoder();
            const dataToSend = encoder.encode(dataString);
            
            try {
                await dataCharacteristic.writeValue(dataToSend);
                updateStatus(`Data Sent: "${dataString}"`);
                console.log(`Data Sent: ${dataString}`);
                return true;
            } catch (error) {
                updateStatus(`Send Error: ${error.message}`, true);
                console.error(error);
                return false;
            }
        }

        /**
         * Sends data from the manual input fields.
         */
        function sendManualData() {
            const time = inputTime.value;
            const temp = parseFloat(inputTemp.value).toFixed(1);
            const weather = inputWeather.value;
            const dataString = `${time},${temp}C,${weather}`;
            sendData(dataString);
        }


        // --- Weather API Functions ---

        /**
         * Fetches weather data from WeatherAPI.com using the fixed city name.
         */
        async function fetchWeatherData() {
            // Check if the key is empty or the city is not set. 
            // The previous bug-check was incorrectly comparing against the key itself.
            if (!WEATHER_API_KEY || !TARGET_CITY) {
                updateStatus("API Key or Target City is missing!", true);
                console.error("API Key is missing or invalid.");
                return null;
            }

            // Create a unique timestamp (cache-buster) to prevent browser caching
            const cacheBuster = new Date().getTime();
            
            // Using the WeatherAPI.com endpoint structure for current weather
            // Appending the cache-buster: &_=${cacheBuster}
            const url = `https://api.weatherapi.com/v1/current.json?key=${WEATHER_API_KEY}&q=${TARGET_CITY}&aqi=no&_=${cacheBuster}`;

            try {
                const response = await fetch(url);
                
                // WeatherAPI uses 'error' object inside JSON for failures like 400, 403
                if (!response.ok) {
                     // Try to read the error body
                    const errorData = await response.json();
                    const errorMessage = errorData.error ? errorData.error.message : `HTTP error! status: ${response.status}`;
                    
                    if (response.status === 403) {
                        // This corresponds to the old OWM 401 error (key inactive or invalid)
                        throw new Error(`Invalid Key/Forbidden Access: "${errorMessage}". Please check your key status on the WeatherAPI.com dashboard.`);
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                
                // Extract and format data from WeatherAPI.com JSON structure
                const temperature = data.current.temp_c.toFixed(1); // Temperature in Celsius
                const description = data.current.condition.text;     // Full weather description
                const city = data.location.name || TARGET_CITY;

                currentLocationElement.textContent = `Location: ${city}`;

                // Get current time (HH:MM) from the client's machine
                const now = new Date();
                const timeString = now.toTimeString().substring(0, 5);

                // Format: "HH:MM,TT.TC,WeatherCondition"
                const dataString = `${timeString},${temperature}C,${description}`;
                
                return dataString;

            } catch (error) {
                console.error("Error fetching weather data:", error);
                updateStatus(`Weather Fetch Error for ${TARGET_CITY}: ${error.message}`, true);
                return null;
            }
        }
        
        /**
         * Fetches the weather data and then sends it to the ESP32.
         */
        async function fetchAndSendWeatherData() {
            updateStatus('Fetching real-time weather...');
            const dataString = await fetchWeatherData();
            if (dataString) {
                sendData(dataString);
            }
        }

        /**
         * Toggles the automatic weather update interval.
         */
        function toggleAutoUpdate() {
            const checkbox = document.getElementById('autoUpdateCheckbox');
            if (checkbox.checked) {
                if (isConnected) {
                    // Fetch immediately, then set interval (5 minutes = 300000ms)
                    fetchAndSendWeatherData(); 
                    autoUpdateInterval = setInterval(fetchAndSendWeatherData, 300000);
                    updateStatus("Auto-Update ENABLED. Next update in 5 min.");
                } else {
                    updateStatus("Please connect to ESP32 before enabling auto-update.", true);
                    checkbox.checked = false;
                }
            } else {
                clearInterval(autoUpdateInterval);
                updateStatus("Auto-Update DISABLED.");
            }
        }

        // Set up the disconnect/connect functionality for the button
        connectButton.addEventListener('click', () => {
            if (isConnected && bleDevice && bleDevice.gatt.connected) {
                bleDevice.gatt.disconnect();
            } else if (!isConnected) {
                connect();
            }
        });
    </script>
</body>
</html>
